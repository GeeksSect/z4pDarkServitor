# Компилятор

2 прикольные нефоннеймановские архитектуры

Проц:
1 РОН (А), на 1 машинное слово
Регистр инструкций (I), 1/2 слова

Память:
набор ячеек, по 1 слову в ячейке, 100 ячеек

Команды:
10 ввод данных в указанную ячейку
11 вывод значения указанной ячейки на экран
20 загружает ячейку памяти в А (load)
21 сохраняет А в память (store)
22 A = T
23 T = A
24 A = BS
25 BS = A
26 PUSH (A)
27 POP (A)
30 складывает А с памятью, результат в А
31 -
32 *
33 /
34 MOD
35 LITERAL
40 JUMP
41 BRANCHNE (переход, если А < 0)
42 BRANCHZERO (переход, если А = 0)
43 HALT
44 CALL текущее значение регистра инструкций помещается в стек, управление переходит по указанному адресу
45 RET управление передается по адресу в стеке, из стека выталкивается кол-во слов 4 для 4504

вызов функции:
    1) если есть возвращаемый аргумент, то выполнить PUSH
    2) параметры функции ПУШаются в обратном порядке
    3) вызов КОЛЛ с соотв адресом
    4) пушается BS
    5) в BS помещается текущий Т

завершение работы функции:
    1) попнуть все локальные переменные
    2) извлечь из стека значение BS
    3) RET c количеством параметров
    4) результат функции на вершине стека, можно использовать его по своему усмотрению

00 +1007
01 +1008
02 +2007
03 +3008
04 +2109
05 +1109
06 +4300


Стековый регистр (Т) 1/2 слова (указатель на вершину стека)
Регистр смещения (BS) 1/2 слова (A+=mem[addr+BS])


Ненейман: "логичная" память (по диапазону): передается диапазон ячеек (2 адреса) и применяющаяся к ним операция, например, AND 010 - провести логическое умножение каждой тройки ячеек на 010 (операция изменения) или ANDR 010 - логически умножить 010 на все тройки ячеек и сохранить результат в аккумуляторе. Плюсы: быстро вычисляются большие объемы данных. Минусы: дополнительные проверки при доступе к памяти.

текст программы:
10 rem determine and print the larger of two ints
20 input s
30 input t
40 if s >= t goto 70
50 print t
60 goto 99
70 print s
99 end


Компиляция по Дейтлу:
счетчик инструкций (I = 0), переменных (V = 99)
читаем файл исходного кода
разбираем его построчно и заполняем таблицу символов записями (номер строки/имя переменной, label/var, соответствующий адрес памяти)
    для команды записываем label и отсчитываем необходимые инструкции для I
    если переменная, сохраняем ей адрес V, уменьшаем V на 1
    если
    если адрес перехода неизвестен, ставим -01
бежим по таблице символов

LITERAL: A = (|A|*100 + |val|) * sign(val)
GOSUB(s,1) 300
300 arg0, arg1
return arg0+1

код:
00 +1099
01 +1098
02 +2099
03 +3198
04 +4106
05 +4008
06 +1198
07 +4009
08 +1110
09 +4300

таблица символов:
"10" label 00
"20" label 00
"s" var 99
"30" label 01
"t" var 98
"40" label 02
"70" label 08
"50" label 06
"99" label 09
"70" label 08
"99" label 09
